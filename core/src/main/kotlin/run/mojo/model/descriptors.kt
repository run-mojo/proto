package run.mojo.model

import com.squareup.moshi.JsonAdapter
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.schema.ProtoType
import run.mojo.compiler.ModelTransformer
import run.mojo.wire.JavaKind


data class Module(
    val name: String,
    val version: String,
    val hash: Long,
    val packages: Map<String, ModulePackage>,
    val all: ModulePackage
)


data class ModulePackage(
    val name: String,
    val declaredByClass: Map<Class<*>, DeclaredDescriptor>,
    val declaredByName: Map<ByteArray, DeclaredDescriptor>,
    val actionsByClass: Map<Class<*>, ActionDescriptor>
)


/**
 *
 */
enum class NamingStrategy {
    PREFIX,
    SUFFIX,
    PREFIX_AND_SUFFIX
}

/**
 * Component mutation strategy. Goal is immutability with maximal convenience.
 * Mutability allows for numerous integrations and adaptation with entity mappers and other existing systems.
 */
enum class Mutability {
    /** The component is freely mutable. */
    MUTABLE,

    /** No builder is used and the component is final on construction. */
    IMMUTABLE,

    /** The component is mutable by way of a builder. */
    BUILDER
}


/**
 *
 */
enum class GenerationSource {
    /**
     * Generated through Reflection api.
     */
    REFLECT,
    /**
     * Generated by annotation compiler.
     */
    ANNOTATION,
}


//////////////////////////////////////////////////////////////////////////////////////////
// Message Source
//////////////////////////////////////////////////////////////////////////////////////////

val MESSAGE_AUTO_VALUE = "AUTO_VALUE"
val GOOGLE_PROTOBUF = "GOOGLE_PROTOBUF"
val SQUARE_WIRE = "SQUARE_WIRE"
val LOMBOK_DATA = "LOMBOK_DATA"
val LOMBOK_VALUE = "LOMBOK_VALUE"
val POJO = "POJO"
val KOTLIN_DATA = "KOTLIN_DATA"
val KOTLIN_CLASS = "KOTLIN_CLASS"
val BUILDER_AUTO_VALUE = "AUTO_VALUE"

fun toDescriptors(
    source: GenerationSource,
    provider: String,
    generated: Long,
    model: ModelTransformer
) {
    model.packages.values.map {
        it.nested.values.filter { it is EnumModel }.map { it as EnumModel }.map {
            EnumDescriptor(
                genSource = source,
                genProvider = provider,
                generated = generated,
                packageName = it.packageName,
                name = it.name,
                relativeName = it.relativeName,
                simpleName = it.simpleName,
                values = it.constants
            )
        }
    }
}

data class ActionDescriptor(val name: String)


interface DeclaredDescriptor {

}


/**
 *
 */
data class EnumDescriptor(
    val genSource: GenerationSource,
    val genProvider: String = "MOJO",
    val generated: Long,
    val packageName: String,
    val name: String,
    val relativeName: String,
    val simpleName: String,
    val values: List<EnumConstant>
)

/**
 *
 */
data class MessageDescriptor<T>(
    val version: Long,
    val genSource: GenerationSource,
    val genProvider: String = "MOJO",
    val generated: Long,
    val packageName: String,
    val name: String,
    val relativeName: String,
    val simpleName: String,
    val wireClassName: String,
    val inherits: List<ProtoType>,
    val fields: Map<String, FieldDescriptor>,
    val fieldsByTag: Map<Int, FieldDescriptor>,
    val flavor: Flavor,
    val adapters: Adapters<T>,
    val validExamples: List<Validator> = emptyList()
)

/**
 *
 */
data class BuilderDescriptor(
    val provider: String,
    val fluentStyle: Boolean,
    val fluent: Boolean
)

/**
 *
 */
data class Adapters<T>(
    val proto: ProtoAdapter<T>,
    val json: JsonAdapter<T>
)

/**
 *
 */
data class FieldDescriptor(
    /**
     *
     */
    val name: String,
    /**
     *
     */
    val javaKind: JavaKind,

    val protoKind: ProtoKind,
    val jsonKind: JsonKind,
    /**
     *
     */
    val protoType: ProtoType,
    /**
     * Path
     */
    val declaring: List<ProtoType>,
    val defaultValue: Any?
)

data class Validator(val fields: List<FieldDescriptor>)
